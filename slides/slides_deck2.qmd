---
title: "Coding in R"
subtitle: "Deck 2 &bull; Data Wrangling in R"
date: "2024-11-13"
date-format: "long"
author: "Carlo Bottai"
institute: "Postdoctoral Fellow <br> Department of Economics, Management, and Statistics (DEMS) <br> University of Milano-Bicocca"
toc: true
toc-depth: 1
from: markdown+emoji
format:
 revealjs:
   theme: [serif, files/custom.scss]
   slide-number: true
   aspect-ratio: "16:9"
   progress: true
   min-scale: 1
   max-scale: 1
   width: 1150
   lightbox: true
   pdf-max-pages-per-slide: 1
---

# Data Wrangling {.smaller}

-   Importing 
-   Tidying
-   Transforming

## The 80-20 Rule of Data Science

-   Data wrangling consists of transforming the "raw" data into some format that is more appropriate for the purposes of your analysis.
-   Data scientists are used to saying that they spend 80% of their time on data wrangling, and only the other 20% on all the rest.

# Data Wrangling -- Tidying

## From Spreadsheets to Data Frames

![](images/spreadsheet_to_dataframe.png)

## Data Frames {.smaller}

::::: columns
::: {.column width="48%"}
```r
Indometh
   Subject time conc
1        1 0.25 1.50
2        1 0.50 0.94
3        1 0.75 0.78
4        1 1.00 0.48
5        1 1.25 0.37
6        1 2.00 0.19
7        1 3.00 0.12
8        1 4.00 0.11
9        1 5.00 0.08
10       1 6.00 0.07
```

[Long format]{.mark}

-   One column (here "Subject") reports the observation.
-   Another column (here "time") reports the variables.
-   A third column (here "conc") reports the corresponding values.
:::

::: {.column .gutter-left width="48%"}
```r
> iris
    Sepal.Length Sepal.Width ... Species
1            5.1         3.5 ... setosa
2            4.9         3.0 ... setosa
3            4.7         3.2 ... setosa
4            4.6         3.1 ... setosa
5            5.0         3.6 ... setosa
6            5.4         3.9 ... setosa
7            4.6         3.4 ... setosa
8            5.0         3.4 ... setosa
9            4.4         2.9 ... setosa
10           4.9         3.1 ... setosa
```

[Wide format]{.mark}

-   Each column represents a variable.
-   Each row represents an observation.
:::
:::::

<!--
## Tidy Data Principles
-   Each variable forms a column
-   Each observation forms a row
-   Each type of observational unit forms a table
-   Tidy data is a standard way of mapping the meaning of a dataset to its structure
-   Tidy data is not the same as tidy code
-   Tidy data makes it easier to manipulate, model, and visualize data
-   The `tidyr` package provides functions to help you tidy your data
-   Key functions: `pivot_longer()`, `pivot_wider()`, `separate()`, `unite()`
-->

## Reshaping Data: `pivot_longer()` {.smaller}

::::: columns
::: {.column width="48%"}
-   You can transform a [wide]{.mark} data.frame [into a long one]{.mark} using the
    `pivot_longer()` function from the `tidyr` package.
    -   This is useful when you have multiple columns that represent the same type of variable.
        -   *Example:* Converting multiple measurement columns into a single measurement
            column with an additional variable column.
    -   The new data frame will have:
        -   A column representing the name of the subject observed (or the observation ID).
        -   Another column representing the name of the variable observed.
        -   A third column representing the value that a given variable takes for a given subject.
:::

::: {.column .gutter-left width="48%"}
```r
iris_long <- tidyr::pivot_longer(
  data = iris,
  cols = c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width),
  # names_to = "name",
  # values_to = "value"
)

iris_long
# A tibble: 600 × 3
   Species name         value
   <fct>   <chr>        <dbl>
 1 setosa  Sepal.Length   5.1
 2 setosa  Sepal.Width    3.5
 3 setosa  Petal.Length   1.4
 4 setosa  Petal.Width    0.2
 5 setosa  Sepal.Length   4.9
...
```
:::
:::::

## Reshaping Data: `pivot_wider()` {.smaller}

::::: columns
::: {.column width="48%"}
-   You can transform a [long]{.mark} data.frame [into a wide one]{.mark} using the `pivot_wider()` function from the `tidyr` package.
    -   This is useful when you want to spread a key-value pair across multiple columns.
        -   *Example:* Converting a single measurement column into multiple measurement columns based on a variable column.
    -   The new data frame will have:
        -   A row for each subject observed.
        -   A column for each information piece observed about the subject.
:::

::: {.column .gutter-left width="48%"}
```r
Indometh_wide <- tidyr::pivot_wider(
  data = Indometh,
  id_cols = "Subject",
  names_from = "time",
  names_prefix = "time_",
  values_from = "conc"
)

Indometh_wide
# A tibble: 6 × 12
  Subject time_0.25 time_0.5 time_0.75 time_1
  <ord>       <dbl>    <dbl>     <dbl>  <dbl>
1 1            1.5      0.94      0.78   0.48
2 2            2.03     1.63      0.71   0.7 
3 3            2.72     1.49      1.16   0.8 
4 4            1.85     1.39      1.02   0.89
5 5            2.05     1.04      0.81   0.39
6 6            2.31     1.44      1.03   0.84
# ℹ 7 more variables: time_1.25 <dbl>, time_2 <dbl>,
#   time_3 <dbl>, time_4 <dbl>, time_5 <dbl>,
#   time_6 <dbl>, time_8 <dbl>
```
:::
:::::

# Data Wrangling -- Importing

## CSV Files

::::: columns
::: {.column width="48%"}
-   A comma-separated values (CSV) file is a text file commonly used to store tabular data.
    -   Each line of the file is a data record.
    -   Each record consists of one or more fields, separated by commas.
:::

::: {.column .gutter-left width="48%"}
```
year,min_gdppc,max_gdppc,ratio_minmax_grppc
1950,462,48436,104.84
1951,489,48653,99.49
1952,504,47990,95.22
1953,513,49989,97.44
1954,521,52920,101.57
```
:::
:::::

## Importing CSV Files in R

::::: columns
::: {.column width="48%"}
-   You can read the data from a CSV file with `read.csv("<path/to/file.csv>")`.
:::

::: {.column .gutter-left width="48%"}
```r
dta <- read.csv(
    "<path/to/file.csv>"
)
```
:::
:::::

## Saving Data Frames as CSV Files

::::: columns
::: {.column width="48%"}
-   You can save an R data frame to a CSV file with `write.csv(<data.frame>, "<folder/file.csv>")`.
:::

::: {.column .gutter-left width="48%"}
```r
write.csv(
    <data.frame>,
    "<path/to/file.csv>"
)
```
:::
:::::

## Excel Spreadsheets

-   Another common format to share data files is Microsoft Excel (`<file>.xlsx`).

## Importing Excel Files in R

::::: columns
::: {.column width="48%"}
-   You can read the data from an Excel file with the `read_excel("<path/to/file.xlsx>")` function from the `readxl` package.
    -   You can specify the sheet to read with the `sheet` argument either with the position of the sheet (e.g., 1) or the name of the sheet (e.g., "Sheet1"). Default is the first sheet.
:::

::: {.column .gutter-left width="48%"}
```r
dta <- readxl::read_excel(
    "<path/to/file.xlsx>",
    # sheet = "Sheet1"
)
```
:::
:::::

## Data Types in R {.smaller}

::::: columns
::: {.column width="48%"}
-   Each R object is of a type.
    -   The same holds for data frames' columns (being them R objects themselves).
    -   This is key to knowing which kind of functions you can apply to which columns.
-   You can either directly specify the class of a column while reading the data or you can transform the column into the proper class type later on.
:::

::: {.column .gutter-left width="48%"}
```r
dta <- read.csv(
    "tutorials/empl_2023.csv"
)

str(dta)
'data.frame':	2411 obs. of  5 variables:
 $ nace_r2_code : chr  "A01" "A01" "A01" ...
 $ nace_r2_label: chr  "Crop and animal ...
 $ geo_code     : chr  "AT" "BE" "BG" "CY" ...
 $ geo_label    : chr  "Austria" "Belgium" ...
 $ employment   : num  110.8 47.7 131 8.6 ...

dta <- read.csv(
    "tutorials/empl_2023.csv",
    colClasses = c(
        nace_r2_code = "factor"
    )
)

str(dta)
'data.frame':	2411 obs. of  5 variables:
 $ nace_r2_code : Factor w/ 89 levels "A01", ...
 $ nace_r2_label: chr  "Crop and animal ...
 $ geo_code     : chr  "AT" "BE" "BG" "CY" ...
 $ geo_label    : chr  "Austria" "Belgium" ...
 $ employment   : num  110.8 47.7 131 8.6 ...
```
:::
:::::

## Data Types in R {.smaller}

::::: columns
::: {.column width="48%"}
-   Each R object is of a type.
    -   The same holds for data frames' columns (being them R objects themselves).
    -   This is key to knowing which kind of functions you can apply to which columns.
-   You can either directly specify the class of a column while reading the data or you can transform the column into the proper class type later on.
:::

::: {.column .gutter-left width="48%"}
```r
dta <- read.csv(
    "tutorials/empl_2023.csv"
)

str(dta)
'data.frame':	2411 obs. of  5 variables:
 $ nace_r2_code : chr  "A01" "A01" "A01" ...
 $ nace_r2_label: chr  "Crop and animal ...
 $ geo_code     : chr  "AT" "BE" "BG" "CY" ...
 $ geo_label    : chr  "Austria" "Belgium" ...
 $ employment   : num  110.8 47.7 131 8.6 ...

dta <- transform(
    dta,
    nace_r2_code = factor(nace_r2_code)
)

str(dta)
'data.frame':	2411 obs. of  5 variables:
 $ nace_r2_code : Factor w/ 89 levels "A01", ...
 $ nace_r2_label: chr  "Crop and animal ...
 $ geo_code     : chr  "AT" "BE" "BG" "CY" ...
 $ geo_label    : chr  "Austria" "Belgium" ...
 $ employment   : num  110.8 47.7 131 8.6 ...
```
:::
:::::

# Data Wrangling -- Transforming

## Sorting {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [ordering the rows of a data frame]{.mark} by the values of selected columns.
    -   You can use the R function `order(<col>)` to achieve this.
    -   It returns a vector of indices that can be used to reorder the data frame.
    -   The data frame can then be reordered by using the returned indices as if you were subsetting the original data frame.
    -   You can sort by multiple columns by providing multiple arguments to the `order()` function.

:::

::: {.column .gutter-left width="48%"}
```r
mtcars[order(mtcars$mpg), ]
                     mpg cyl  disp  hp drat    wt  ...
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250  ...
Lincoln Continental 10.4   8 460.0 215 3.00 5.424  ...
Camaro Z28          13.3   8 350.0 245 3.73 3.840  ...
Duster 360          14.3   8 360.0 245 3.21 3.570  ...
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345  ...

mtcars[order(-mtcars$mpg, mtcars$cyl), ]
                     mpg cyl  disp  hp drat    wt  ...
Toyota Corolla      33.9   4  71.1  65 4.22 1.835  ...
Fiat 128            32.4   4  78.7  66 4.08 2.200  ...
Honda Civic         30.4   4  75.7  52 4.93 1.615  ...
Lotus Europa        30.4   4  95.1 113 3.77 1.513  ...
Fiat X1-9           27.3   4  79.0  66 4.08 1.935  ...
```
:::
:::::

## Sorting {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [ordering the rows of a data frame]{.mark} by the values of selected columns.
    -   You can use the R function `order(<col>)` to achieve this.
    -   It returns a vector of indices that can be used to reorder the data frame.
    -   The data frame can then be reordered by using the returned indices as if you were subsetting the original data frame.
    -   You can sort by multiple columns by providing multiple arguments to the `order()` function.
    -   By default, it sorts in ascending order. You can sort in descending order by using the minus sign `-` before the column name.
:::

::: {.column .gutter-left width="48%"}
```r
mtcars[order(mtcars$mpg), ]
                     mpg cyl  disp  hp drat    wt  ...
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250  ...
Lincoln Continental 10.4   8 460.0 215 3.00 5.424  ...
Camaro Z28          13.3   8 350.0 245 3.73 3.840  ...
Duster 360          14.3   8 360.0 245 3.21 3.570  ...
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345  ...

mtcars[order(-mtcars$mpg, mtcars$cyl), ]
                     mpg cyl  disp  hp drat    wt  ...
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250  ...
Lincoln Continental 10.4   8 460.0 215 3.00 5.424  ...
Camaro Z28          13.3   8 350.0 245 3.73 3.840  ...
Duster 360          14.3   8 360.0 245 3.21 3.570  ...
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345  ...
```
:::
:::::

## Filtering {.smaller}

::::: columns
::: {.column width="50%"}
-   This operation consists of [subsetting a data frame]{.mark}, retaining all rows that
    satisfy some given conditions.
    -  You can use the R function `subset(<data.frame>, subset = <cond expr>)` to achieve
       this (where the conditional expression is something like `<col> == <cond>`).
    - Alternatively, you can filter rows of a data frame passing the conditional
      expression inside the square brackets. For example,
      `<data.frame>[<data.frame>$<col> == <cond>, ]`.
    -   The conditional expression should return a logical vector indicating which rows to
        keep (`TRUE`) or discard (`FALSE`).
    -   To write a conditional expression, you can use [relational operators]{.mark} to
        express the conditions (e.g., `==`, `!=`, `>`, or `>=`) and
        [logical operators]{.mark} to combine multiple conditions (e.g., `&`, or `|`).
:::

::: {.column .gutter-left width="46%"}
```r
subset(mtcars, subset = mtcars$mpg > 20)
                mpg cyl  disp  hp drat  ...
Mazda RX4      21.0   6 160.0 110 3.90  ...
Mazda RX4 Wag  21.0   6 160.0 110 3.90  ...
Datsun 710     22.8   4 108.0  93 3.85  ...
Hornet 4 Drive 21.4   6 258.0 110 3.08  ...
Merc 240D      24.4   4 146.7  62 3.69  ...

mtcars[mtcars$mpg > 20, ]
                mpg cyl  disp  hp drat  ...
Mazda RX4      21.0   6 160.0 110 3.90  ...
Mazda RX4 Wag  21.0   6 160.0 110 3.90  ...
Datsun 710     22.8   4 108.0  93 3.85  ...
Hornet 4 Drive 21.4   6 258.0 110 3.08  ...
Merc 240D      24.4   4 146.7  62 3.69  ...

mtcars[which(mtcars$mpg > 20), ]
                mpg cyl  disp  hp drat  ...
Mazda RX4      21.0   6 160.0 110 3.90  ...
Mazda RX4 Wag  21.0   6 160.0 110 3.90  ...
Datsun 710     22.8   4 108.0  93 3.85  ...
Hornet 4 Drive 21.4   6 258.0 110 3.08  ...
Merc 240D      24.4   4 146.7  62 3.69  ...
```
:::
:::::

## Filtering {.smaller}

::::: columns
::: {.column width="50%"}
-   This operation consists of [subsetting a data frame]{.mark}, retaining all rows that
    satisfy some given conditions.
    -  You can use the R function `subset(<data.frame>, subset = <cond expr>)` to achieve
       this (where the conditional expression is something like `<col> == <cond>`).
    - Alternatively, you can filter rows of a data frame passing the conditional
      expression inside the square brackets. For example,
      `<data.frame>[<data.frame>$<col> == <cond>, ]`.
    -   The conditional expression should return a logical vector indicating which rows to
        keep (`TRUE`) or discard (`FALSE`).
    -   To write a conditional expression, you can use [relational operators]{.mark} to
        express the conditions (e.g., `==`, `!=`, `>`, or `>=`) and
        [logical operators]{.mark} to combine multiple conditions (e.g., `&`, or `|`).
:::

::: {.column .gutter-left width="46%"}
```r
mtcars[mtcars$mpg > 20 & mtcars$cyl == 4, ]
                mpg cyl  disp  hp drat    wt  ...
Datsun 710     22.8   4 108.0  93 3.85 2.320  ...
Merc 240D      24.4   4 146.7  62 3.69 3.190  ...
Merc 230       22.8   4 140.8  95 3.92 3.150  ...
Fiat 128       32.4   4  78.7  66 4.08 2.200  ...
Honda Civic    30.4   4  75.7  52 4.93 1.615  ...
```
:::
:::::

## Selecting {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [selecting the variables in a data frame]{.mark} that you want to keep for your analysis.
    -   You can use the R function `subset(<data.frame>, select = <cols>)` to achieve this (where the vector `<cols>` is something like `c("<col1>", "<col2>")`).
    -   Alternatively, you can directly select columns of a data frame passing the vector of column names inside the square brackets. For example, `<data.frame>[ , c("<col1>", "<col2>")]`.
    -   You can also deselect (or remove, or drop) columns by using the minus sign `-` before the column name.
    -   You can also use functions to select variables based on their properties (e.g., selecting all numeric columns).
:::

::: {.column .gutter-left width="48%"}
```r
subset(mtcars, select = c("mpg", "cyl"))
                     mpg cyl
Mazda RX4           21.0   6
Mazda RX4 Wag       21.0   6
Datsun 710          22.8   4
Hornet 4 Drive      21.4   6
Hornet Sportabout   18.7   8

mtcars[, c("mpg", "cyl")]
                     mpg cyl
Mazda RX4           21.0   6
Mazda RX4 Wag       21.0   6
Datsun 710          22.8   4
Hornet 4 Drive      21.4   6
Hornet Sportabout   18.7   8
```
:::
:::::

## Selecting {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [selecting the variables in a data frame]{.mark} that you want to keep for your analysis.
    -   You can use the R function `subset(<data.frame>, select = <cols>)` to achieve this (where the vector `<cols>` is something like `c("<col1>", "<col2>")`).
    -   Alternatively, you can directly select columns of a data frame passing the vector of column names inside the square brackets. For example, `<data.frame>[ , c("<col1>", "<col2>")]`.
    -   You can also deselect (or remove, or drop) columns by using the minus sign `-` before the column name.
    -   You can also use functions to select variables based on their properties (e.g., selecting all numeric columns).
:::

::: {.column .gutter-left width="48%"}
```r
subset(mtcars, select = -carb)
                     mpg cyl ... am gear
Mazda RX4           21.0   6 ...  1    4
Mazda RX4 Wag       21.0   6 ...  1    4
Datsun 710          22.8   4 ...  1    4
Hornet 4 Drive      21.4   6 ...  0    3
Hornet Sportabout   18.7   8 ...  0    3

mtcars[, names(mtcars) != "carb"]
                     mpg cyl ... am gear
Mazda RX4           21.0   6 ...  1    4
Mazda RX4 Wag       21.0   6 ...  1    4
Datsun 710          22.8   4 ...  1    4
Hornet 4 Drive      21.4   6 ...  0    3
Hornet Sportabout   18.7   8 ...  0    3

# You can also do the following,
#  but you need to modify the original data frame
mtcars$carb <- NULL
mtcars
                     mpg cyl ... am gear
Mazda RX4           21.0   6 ...  1    4
Mazda RX4 Wag       21.0   6 ...  1    4
Datsun 710          22.8   4 ...  1    4
Hornet 4 Drive      21.4   6 ...  0    3
Hornet Sportabout   18.7   8 ...  0    3
```
:::
:::::

## Transforming {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [adding new variables to a data frame]{.mark}, while preserving the existing ones
    -   :danger: However, new variables overwrite existing variables of the same name.
    -   You can use the R function `transform(<data.frame>, <new_col> = <fun>(<old_col>))` to achieve this.
        -   The output of this operation is a new data frame.
    -   Alternatively, you can assign the output of an operation to a (new) variable of a data frame, using something like `<data.frame>$<new_col> <- <fun>(<data.frame>$<old_col>)`.
:::

::: {.column .gutter-left width="48%"}
```r
transform(mtcars, cyl_neg = -cyl)
                     mpg cyl  disp  hp ... cyl_neg
Mazda RX4           21.0   6 160.0 110 ...      -6
Mazda RX4 Wag       21.0   6 160.0 110 ...      -6
Datsun 710          22.8   4 108.0  93 ...      -4
Hornet 4 Drive      21.4   6 258.0 110 ...      -6
Hornet Sportabout   18.7   8 360.0 175 ...      -8

transform(mtcars, cyl = -cyl)
                     mpg cyl  disp  hp drat  ...
Mazda RX4           21.0  -6 160.0 110 3.90  ...
Mazda RX4 Wag       21.0  -6 160.0 110 3.90  ...
Datsun 710          22.8  -4 108.0  93 3.85  ...
Hornet 4 Drive      21.4  -6 258.0 110 3.08  ...
Hornet Sportabout   18.7  -8 360.0 175 3.15  ...

mtcars$cyl_neg <- -mtcars$cyl
```
:::
:::::

## Extracting Unique Elements {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [extracting only unique rows from a data frame]{.mark} (or unique values from a vector).
    -   You can use `unique(<data.frame>)` (or `unique(<vector>)`) to achieve it.
:::

::: {.column .gutter-left width="48%"}
```r
unique(subset(dta, select = geo_code))
    geo_code
1         AT
2         BE
3         BG
4         CY
5         CZ
6         DE
7         DK
8         EE
9         EL
10        ES

unique(dta$geo_code)
 [1] "AT"        "BE"        "BG"        "CY"
 [5] "CZ"        "DE"        "DK"        "EE"
 [9] "EL"        "ES"
```
:::
:::::

## Summarizing {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [summarizing a variable]{.mark} of a data frame.
    -   You can apply a function on a column of a data frame to achieve it.
:::

::: {.column .gutter-left width="48%"}
```r
mean(mtcars$disp)
[1] 230.7219

length(mtcars$disp)
[1] 32
```
:::
:::::

## Summarizing {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [summarizing a variable]{.mark} of a data frame.
    -   You can apply a function on a column of a data frame to achieve it.
    -   Alternatively, you can use the R function `aggregate(<formula>, <data.frame>, <fun>(<col>))`.
        -   This function creates a new data frame with one column for each summary statistic specified.
:::

::: {.column .gutter-left width="48%"}
```r
aggregate(
    disp ~ 1,
    mtcars,
    \(col) c(
        mean = mean(col),
        n = length(col)
    )
)
  disp.mean   disp.n
230.7219  32.0000
```
:::
:::::

## Summarizing {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [summarizing a variable]{.mark} of a data frame.
    -   You can apply a function on a column of a data frame to achieve it.
    -   Alternatively, you can use the R function `aggregate(<formula>, <data.frame>, <fun>(<col>))`.
        -   This function creates a new data frame with one column for each summary statistic specified.
        -    You can specify a grouping variable to calculate the summary statistic by group, specifying it in the formula.
:::

::: {.column .gutter-left width="48%"}
```r
aggregate(
    disp ~ cyl,
    mtcars,
    \(col) c(
        mean = mean(col),
        n = length(col)
    )
) 
cyl disp.mean   disp.n
1   4  105.1364  11.0000
2   6  183.3143   7.0000
3   8  353.1000  14.0000

aggregate(
    cbind(mpg, disp) ~ cyl,
    mtcars,
    \(col) c(
        mean = mean(col),
        n = length(col)
    )
)
 cyl mpg.mean    mpg.n disp.mean   disp.n
1   4 26.66364 11.00000  105.1364  11.0000
2   6 19.74286  7.00000  183.3143   7.0000
3   8 15.10000 14.00000  353.1000  14.0000
```
:::
:::::

## Joining {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [adding columns from the RHS data frame to the LHS one]{.mark}, matching rows based on the keys that you specify.
    -   You can use the R function `merge(<LHS>, <RHS>, by = <col>)` to achieve it.
    -   An "inner join" (default) includes all rows that are both in the LHS and RHS data frames.
    -   A "left join" (`all.x = TRUE`) includes all rows that are in the LHS data frame.
:::

::: {.column .gutter-left width="48%"}
```r
df1 <- data.frame(
    ID = c(1, 2, 3),
    Name = c("A", "B", "C"),
    Age = c(25, 30, 35)
)

df2 <- data.frame(
    ID = c(2, 3, 4),
    Occupation = c("Eng.", "Teach.", "Doc."),
    Salary = c(5000, 4000, 6000)
)
```
:::
:::::

## Joining {.smaller}

::::: columns
::: {.column width="48%"}
-   This operation consists of [adding columns from the RHS data frame to the LHS one]{.mark}, matching rows based on the keys that you specify.
    -   You can use the R function `merge(<LHS>, <RHS>, by = <col>)` to achieve it.
    -   An "inner join" (default) includes all rows that are both in the LHS and RHS data frames.
    -   A "left join" (`all.x = TRUE`) includes all rows that are in the LHS data frame.
:::

::: {.column .gutter-left width="48%"}
```r
merge(
    df1, df2,
    by = "ID"
)
  ID Name Age Occupation Salary
1  2    B  30       Eng.   5000
2  3    C  35     Teach.   4000

merge(
    df1, df2,
    by = "ID",
    all.x = TRUE
)
  ID Name Age Occupation Salary
1  1    A  25       <NA>     NA
2  2    B  30       Eng.   5000
3  3    C  35     Teach.   4000
```
:::
:::::

## Joining

![Source: <https://tavareshugo.github.io/r-intro-tidyverse-gapminder/08-joins/index.html>](images/merge_left.png)

## Hands-on Tutorial

-   It is time for a new hands-on tutorial! :rocket:

# Appendix

## References {.smaller}

-   Introductory materials
    -   Adler (2012) *R in a Nutshell (2e)*. O'Reilly.
    -   Grolemund (2014) *Hands-On Programming with R*. O'Reilly. <br>
        <https://rstudio-education.github.io/hopr/>
    -   Peng  (2022) *R Programming for Data Science*. <br>
        <https://bookdown.org/rdpeng/rprogdatascience/>
-   More advanced materials
    -   Grolemund and Wickham (2017) *R for Data Science (2e)*. O'Reilly. <br>
        <https://r4ds.had.co.nz/>
    -   Gagolewski (2024) *Deep R Programming*. <br>
        <https://deepr.gagolewski.com/>
    -   Wilke (2019) *Fundamentals of Data Visualization*. O'Reilly. <br>
        <https://clauswilke.com/dataviz/>
